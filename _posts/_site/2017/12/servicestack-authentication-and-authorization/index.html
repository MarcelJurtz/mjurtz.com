<p>This is the fourth part on my series on how to get started using ServiceStack. Be sure to check out the earlier articles, if you haven’t read them already:</p>

<ul>
  <li><a href="https://blog.mjurtz.com/2017/11/what-is-servicestack/">Part 1 – What is ServiceStack and why should I use it?</a></li>
  <li><a href="https://blog.mjurtz.com/2017/11/servicestack-building-simple-service/">Part 2 – Building a Simple Service</a></li>
  <li><a href="https://blog.mjurtz.com/2017/11/servicestack-using-the-c-client/">Part 3 – Using the C#-Client</a></li>
</ul>

<p>Today, I’ll be adding basic authentication and authorization to the project we’ve created over the last parts. As always, you can get the source code from GitHub.</p>

<h2 id="authentication-vs-authorization">Authentication vs. Authorization</h2>

<p>To be able to use authentication and authorization, we’ll first need to know the difference between both of these.</p>

<p>Authentication basically means to provide a guarantee that you are who you pretend to be. Usually, such a functionality is implemented via username / password combinations.</p>

<p>Authorization on the other hand is used to define, what a user is allowed to do. For example, you might be authorized to moderate comments on a forum.</p>

<h2 id="authentication-in-servicestack">Authentication in ServiceStack</h2>

<p>To authenticate a user, ServiceStack offers several options, check out the <a href="http://docs.servicestack.net/authentication-and-authorization">full documentation</a>. Among others, the following methods are available.</p>

<ul>
  <li>Credentials (username &amp; password combination)</li>
  <li>Basic Auth (HTTP Basic Auth)</li>
  <li>Custom Credentials (Custom login implementation, uses username &amp; password combination)</li>
</ul>

<p>As I mentioned above, this list is by no means complete, I just picked some methods that I’d like to explain in detail in this article. Another option available is authentication via OAuth. This means that you can allow your users to authenticate themselves using their twitter, github, facebook <a href="http://docs.servicestack.net/authentication-and-authorization#oauth-providers">or other</a> accounts.</p>

<h3 id="http-basic-auth">HTTP Basic Auth</h3>

<p>I’d like to go over the detials of implementing authentication functionality by using the HTTP Basic Auth implementation of ServiceStack. The goal of the modifications of our sourcecode is to allow the transfer service only after successful authentication by the user.</p>

<p>Do you remember the _Configure-_method of our _ExpenseTrackerAppHost-_class, which has remained completely empty so far?</p>

<p>We’ll start with this one. The mentioned method servers the instantiation of plugins for ServiceStack. These include various modules that are built into ServiceStack, but which are only available after manual activation. An example of this is the API documentation with Swagger. We will use two such plugins: The <em>AuthFeature</em>-Plugin to enable authentication, and the <em>InMemoryAuthRepository</em> to be able to easily test our code without having to maintain actual users.</p>

<p>The server configuration needs to be adjusted as shown in the snippet below. The first entry you see are the two mentioned elements. Next I created a user, which we can use to test the service.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Configure</span><span class="p">(</span><span class="n">Funq</span><span class="p">.</span><span class="n">Container</span> <span class="n">container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Plugins</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">AuthFeature</span><span class="p">(()</span> <span class="p">=&gt;</span>
        <span class="k">new</span> <span class="nf">AuthUserSession</span><span class="p">(),</span> <span class="k">new</span> <span class="n">IAuthProvider</span><span class="p">[]</span> <span class="p">{</span>
        <span class="k">new</span> <span class="nf">BasicAuthProvider</span><span class="p">()</span> <span class="p">}));</span>

    <span class="kt">var</span> <span class="n">userRepository</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">InMemoryAuthRepository</span><span class="p">();</span>
    <span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IUserAuthRepository</span><span class="p">&gt;(</span><span class="n">userRepository</span><span class="p">);</span>

    <span class="kt">string</span> <span class="n">hash</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">salt</span><span class="p">;</span>

    <span class="k">new</span> <span class="nf">SaltedHash</span><span class="p">().</span><span class="nf">GetHashAndSaltString</span><span class="p">(</span><span class="s">"password"</span><span class="p">,</span> <span class="k">out</span> <span class="n">hash</span><span class="p">,</span> <span class="k">out</span> <span class="n">salt</span><span class="p">);</span>
    
    <span class="n">userRepository</span><span class="p">.</span><span class="nf">CreateUserAuth</span><span class="p">(</span><span class="k">new</span> <span class="n">UserAuth</span>
    <span class="p">{</span>
        <span class="n">Id</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
        <span class="n">DisplayName</span> <span class="p">=</span> <span class="s">"Marcel Jurtz"</span><span class="p">,</span>
        <span class="n">Email</span> <span class="p">=</span> <span class="s">"jurtz@example.com"</span><span class="p">,</span>
        <span class="n">UserName</span> <span class="p">=</span> <span class="s">"MJurtz"</span><span class="p">,</span>
        <span class="n">FirstName</span> <span class="p">=</span> <span class="s">"Marcel"</span><span class="p">,</span>
        <span class="n">LastName</span> <span class="p">=</span> <span class="s">"Jurtz"</span><span class="p">,</span>
        <span class="n">PasswordHash</span> <span class="p">=</span> <span class="n">hash</span><span class="p">,</span>
        <span class="n">Salt</span> <span class="p">=</span> <span class="n">salt</span>
    <span class="p">},</span> <span class="s">"password"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>After the server has been configured, you’ll need to specify which routes require authentication. This is done simply by adding the [Authenticate]-attribute above the specific request-dtos class, like this:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="na">[Authenticate]</span>
<span class="na">[Route("/Expense")]</span>
<span class="na">[Route("/Expense/{Amount}")]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Expense</span> <span class="p">:</span> <span class="n">IReturn</span><span class="p">&lt;</span><span class="n">ExpenseResponse</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">double</span> <span class="n">Amount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The service now won’t return any valid data as long as the user is not logged in. This can be tested by using postman, which will return HTTP statuscode 401 (unauthorized) for any request. If, however, the “<em>Authorization</em>” option (oh, the irony) is activated in the header data, the login works.</p>

<h3 id="custom-credentials-authorization">Custom Credentials Authorization</h3>

<p>Another approach I’d like to cover is the implementation of a custom authentication mechanism. By extending CredentialsAuthProvider and overriding the methods <em>TryAuthenticate</em> and <em>OnAuthenticated</em>, you’re able to implement your very own login functionality, for example to match existing business logic. The following example simply checks for hardcoded credentials to demonstrate the basic functionality.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">CustomCredentialsProvider</span> <span class="p">:</span> <span class="n">CredentialsAuthProvider</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="kt">bool</span> <span class="nf">TryAuthenticate</span><span class="p">(</span><span class="n">IServiceBase</span> <span class="n">authService</span><span class="p">,</span> <span class="kt">string</span> <span class="n">userName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">userName</span> <span class="p">==</span> <span class="s">"MJurtz"</span> <span class="p">&amp;&amp;</span> <span class="n">password</span> <span class="p">==</span> <span class="s">"password"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="n">IHttpResult</span> <span class="nf">OnAuthenticated</span><span class="p">(</span><span class="n">IServiceBase</span> <span class="n">authService</span><span class="p">,</span> <span class="n">IAuthSession</span> <span class="n">session</span><span class="p">,</span> <span class="n">IAuthTokens</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">authInfo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">base</span><span class="p">.</span><span class="nf">OnAuthenticated</span><span class="p">(</span><span class="n">authService</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">authInfo</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><em>TryAuthenticate()</em> is used to test for valid login credentials, <em>OnAuthenticated()</em> will be executed after successful login. To test this, we use postman again. If you use your own mechanisms for authentication, it is necessary to send a request to <em>/Authenticate</em> first. Here, username and password have to be provided in the body-field. Once this request has been successfully completed, ServiceStack’s automatic session functionality provides access to our service as usual.</p>

<h3 id="login-with-the-c-client">Login with the C#-Client</h3>

<p>Of course, you’ll want to be able to access the service with the ServiceStack C#-Client, which I introduced in <a href="https://blog.mjurtz.com/2017/11/servicestack-using-the-c-client/">part 3 of this series</a>.</p>

<p>ServiceStack offers an easy way to access username and password via the C# client. In the case of the <em>BasicAuthProvider</em> this works as follows:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">JsonServiceClient</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">JsonServiceClient</span><span class="p">(</span><span class="s">"http://localhost:61401"</span><span class="p">)</span> <span class="p">{</span> <span class="n">UserName</span> <span class="p">=</span> <span class="s">"MJurtz"</span><span class="p">,</span> <span class="n">Password</span> <span class="p">=</span> <span class="s">"password"</span> <span class="p">};</span></code></pre></figure>

<p>In the case of a custom implementation, access via client is minimally more complicated:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">var</span> <span class="n">authResponse</span> <span class="p">=</span> <span class="n">jsonServiceClient</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="k">new</span> <span class="n">Authenticate</span>
<span class="p">{</span>
    <span class="n">provider</span> <span class="p">=</span> <span class="s">"credentials"</span><span class="p">,</span>
    <span class="n">UserName</span> <span class="p">=</span> <span class="s">"MJurtz"</span><span class="p">,</span>
    <span class="n">Password</span> <span class="p">=</span> <span class="s">"password"</span><span class="p">,</span>
    <span class="n">RememberMe</span> <span class="p">=</span> <span class="k">true</span>
<span class="p">});</span></code></pre></figure>

<h2 id="authorization-in-servicestack">Authorization in ServiceStack</h2>

<p>As explained at the beginning of the article, we differentiate between authentication and authorization. After the first part has been completed, we will now cover the second part.</p>

<p>With regard to authorization in ServiceStack, there are two big points we want to consider: roles and permissions. With the help of permissions we can assign certain rights to individual users. Users can also be grouped into roles, which in turn have certain rights.</p>

<p>Once again, ServiceStack offers a convenient way to manage rights. However, both options work very similarly, so I will not go into the individual elements in detail.</p>

<p>In addition to the Authenticate request from earlier, services can be provided with additional attributes that control the access rights. For filtering to a certain role, this attribute is <em>[RequiredRole (“User”)]</em>, the counterpart for the permission is <em>[RequiredPermission (“DoSomething”)]</em>.</p>

<p>We will continue the example with the BasicAuthProvider created at the beginning and assign rights to the user created there. This is similar in both cases.</p>

<p>In addition to the Authenticate request from earlier, services can be provided with additional attributes that control the access rights. For filtering to a certain role, this attribute is[RequiredRole (“User”)], the counterpart for the permission is[RequiredPermission (“DoSomething”).</p>

<p>We will continue the example with the BasicAuthProvider created at the beginning and assign rights to the user created there. Again, this is similar in both cases. To provide roles and permissions to a user, simply add the specific element either to the Roles- or Permissions-List.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Roles</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">"User"</span> <span class="p">}</span>
<span class="n">Permissions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="s">"DoSomething"</span><span class="p">}</span></code></pre></figure>

<p>As an alternative to my hardcoded roles and permissions, you can of course transfer them to constants or, for more practical purposes, to a database.</p>

<h2>#</h2>
