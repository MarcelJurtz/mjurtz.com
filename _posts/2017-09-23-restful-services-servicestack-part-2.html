---
layout: post
title: RESTful Services with ServiceStack - Part 2
date: 2017-09-23 18:00:14.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- CSharp
tags:
- ".NET"
- ASP.NET
- CSharp
- Development
- Programming
- REST
- ServiceStack
meta:
  _edit_last: '2'
  _adinserter_block_exceptions: ''
  _yoast_wpseo_content_score: '30'
  _yoast_wpseo_primary_category: '42'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1510797301;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:406;}i:1;a:1:{s:2:"id";i:461;}i:2;a:1:{s:2:"id";i:473;}}}}
  _yoast_wpseo_focuskw_text_input: ServiceStack
  _yoast_wpseo_focuskw: ServiceStack
  _yoast_wpseo_linkdex: '89'
  _wpas_done_all: '1'
author:
  login: Marcel
  email: marcel@mjurtz.com
  display_name: Marcel Jurtz
  first_name: Marcel
  last_name: Jurtz
---
<p>In my <a href="http://blog.mjurtz.com/2017/09/creating-restful-services-servicestack/">last post</a>, I've set up a basic RESTful service using ServiceStack. This article deals with the implementation of a corresponding functionality on the client side. The application will query the path provided by the server and apply the pre-defined authentication method, requiring the user to log in with username and password before the application delivers the desired content.</p>
<p>Both projects, client and server are located on my <a href="https://github.com/MarcelJurtz/ServiceStackExamples">GitHub-profile</a> and can be viewed and downloaded there.</p>
<p>The structure of the client is very simple. There are two textboxes for entering username and password, as well as one for entering a name for the <em>hello/{name*}</em> path. The button sends the request and the richtextbox is filled with the response.</p>
<p><img class="aligncenter size-full wp-image-419" src="{{ site.baseurl }}/assets/client_gui.png" alt="ServiceStack Client GUI" width="372" height="232" /></p>
<p>Access to the classes created for the server-side service is required. For this reason, these were also added to the project. This includes <em>Hello</em> and <em>HelloResponse</em>.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">[Route("/hello/{name*}")]
public class Hello : IReturn&lt;HelloResponse&gt;
{
    public string Name { get; set; }
}
public class HelloResponse
{
    public string Result { get; set; }
}</pre>
<p>The same applies to the custom AuthenticationProvider.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">public class CustomAuthenticationProvider : CredentialsAuthProvider
{
    public override bool TryAuthenticate(IServiceBase authService, string userName, string password)
    {
        // Only checks if username equals password
        // implement custom logic here
        return userName.Equals(password);
    }
    public override IHttpResult OnAuthenticated(IServiceBase authService, IAuthSession session, IAuthTokens tokens, Dictionary&lt;string, string&gt; authInfo)
    {
        //session.customElement = "Hello World";
        return base.OnAuthenticated(authService, session, tokens, authInfo);
    }
}</pre>
<p>An additional class has been created to control access to the service. This encapsulates the requests, which can be easily accessed from outside.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">using System;
using ServiceStack;

namespace RESTfulDemoClient
{
    class RESTfulServiceClient : IDisposable
    {
        private const String url = "http://localhost:64424";
        private JsonServiceClient serviceclient;

        private JsonServiceClient getServiceClient(String usern, String passw)
        {
            if(serviceclient == null)
            {
                serviceclient = new JsonServiceClient(url);

                var authResponse = serviceclient.Post(new Authenticate
                {
                    provider = CustomAuthenticationProvider.Name, //= credentials
                    UserName = usern,
                    Password = passw,
                    RememberMe = true,
                });

                serviceclient.AlwaysSendBasicAuthHeader = true;
            }
            return serviceclient;
        }

        public HelloResponse GetHelloResponse(Hello request, String username, String password)
        {
            var client = this.getServiceClient(username, password);
            var response = client.Post(request);
            return response;
        }

        public void Dispose()
        {
            serviceclient = null;
        }
    }
}
</pre>
<p>The class already contains all the logic required for access control, and the method <em>GetHelloResponse</em> can be used to retrieve a response from the <em>Hello</em>-path, which is implemented like this:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">using(var client = new RESTfulServiceClient())
{
    var request = new Hello() { Name = txtRequest.Text };
    try
    {
        var response = client.GetHelloResponse(request, txtUsername.Text, txtPassword.Text);
        txtResponse.Text = response.Result;
    }
    catch (ServiceStack.WebServiceException ex)
    {
        txtResponse.Text = ex.StatusCode + " - " + ex.ErrorMessage;
    }
}</pre>
