---
layout: post
title: LINQ
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories:
- CSharp
tags: []
meta:
  _edit_last: '2'
  _adinserter_block_exceptions: ''
  _yoast_wpseo_focuskw_text_input: LINQ
  _yoast_wpseo_focuskw: LINQ
  _yoast_wpseo_linkdex: '71'
  _yoast_wpseo_content_score: '90'
  _yoast_wpseo_primary_category: '42'
author:
  login: Marcel
  email: marcel@mjurtz.com
  display_name: Marcel Jurtz
  first_name: Marcel
  last_name: Jurtz
---
<p>LINQ (Language Integrated Query) provides an interface to access a wide variety of data sources. LINQ closely resembles the syntax of SQL, also with regard to the language elements. In contrast to SQL, Intellisense understands LINQ, which makes it possible to detect errors in the IDE.</p>
<h2>Getting Started</h2>
<p>I have created a simple class with which we will explore the basics of linq. This class symbolizes a music group and each instance has a name and year of foundation.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">public class Band
{
    public String Name { get; set; }
    public int Foundation { get; set; }
}</pre>
<p>Now I want to use LINQ to filter all elements of a band array created before 2000. The following code example makes this possible:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">class Program
{
    static void Main(string[] args)
    {
        Band[] bands = {
            new Band { Name = "Linkin Park", Foundation = 1996 },
            new Band { Name = "Slipknot", Foundation = 1995 },
            new Band { Name = "Five Finger Death Punch", Foundation = 2005 },
            new Band { Name = "Disturbed", Foundation = 1996 },
            new Band { Name = "Korn", Foundation = 1993 }
        };

        var query = from band in bands where band.Foundation &lt; 2000 select band;

        foreach(var item in query)
        {
            Console.WriteLine("{0} ({1})", item.Name, item.Foundation);
        }

        Console.Read();
    }
}</pre>
<p>You might notice the similarity to SQL, but there is one specific difference visible: LINQ starts with specifying the datasource (from), while SQL starts with the SELECT-statement. The reason for this is that the datasource on which the following queries will be performed needs to be set first.</p>
<p>The subsequent console output looks like this. It contains the desired elements, which corresponds to all entries except Five Finger Death Punch, which was founded in 2005.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="no-highlight">Linkin Park (1996)
Slipknot (1995)
Disturbed (1996)
Korn (1993)</pre>
<p>You can use this approach to search through almost all kinds of data collections, on one condition: The list needs to implement <em>IEnumerable&lt;T&gt;</em>.</p>
<h2>Delayed Execution</h2>
<p>One thing that you'll need to consider, is that LINQ-queries are executed when the results are needed. In the example above, this means that the query will not be executed until the foreach loop. However, this means that the query will be executed each time it is accessed. There is no caching available, which can be good or bad, depending on the individual situation. If the underlying data changes during accesses, you always receive the latest contents. This again can decrease performance, especially when you're loading larger chunks of data.</p>
<h2>Query Operators</h2>
<p>LINQ offers a huge pile of extension methods, also known as <em>query operators</em>. The available operators are listed in the table below.</p>
<table>
<thead>
<tr>
<td>Type</td>
<td>Operator</td>
</tr>
</thead>
<tbody>
<tr>
<td>Aggregates</td>
<td>Aggregate, Average, Count, LongCount, Min, Max, Sum</td>
</tr>
<tr>
<td>Conversion</td>
<td>Cast, OfType, ToArray, ToDictionary, ToList, ToLookup</td>
</tr>
<tr>
<td>Elements</td>
<td>DefaultIfEmpty, ElementAt, ElementAtOrDefault, First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault</td>
</tr>
<tr>
<td>Equality</td>
<td>EqualAll</td>
</tr>
<tr>
<td>Sequence</td>
<td>Empty, Range, Repeat</td>
</tr>
<tr>
<td>Grouping</td>
<td>GroupBy</td>
</tr>
<tr>
<td>Joins</td>
<td>Join, GroupJoin</td>
</tr>
<tr>
<td>Sorting</td>
<td>OrderBy, ThenBy, OrderByDescending, ThenByDescending, Reverse</td>
</tr>
<tr>
<td>Segmentation</td>
<td>Skip, SkipWhile, Take, TakeWhile</td>
</tr>
<tr>
<td>Quantification</td>
<td>All, Any, Contains</td>
</tr>
<tr>
<td>Restrictions</td>
<td>Where</td>
</tr>
<tr>
<td>Projection</td>
<td>Select, SelectMany</td>
</tr>
<tr>
<td>Set</td>
<td>Concat, Distinct, Except, Intersect, Union</td>
</tr>
</tbody>
</table>
<p>As previously mentioned, each query starts with the <em>from</em> keyword. This sets the datasource that should be used to query. At the same time, it specifys a local variable which contains one element of the datasource on which the following comparisons are made.</p>
