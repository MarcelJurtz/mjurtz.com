<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.88.1" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Building a Chess Game in Unity &middot; Marcel Jurtz</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://www.mjurtz.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://www.mjurtz.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://www.mjurtz.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://www.mjurtz.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="sidebar-about">
            <a href="https://www.mjurtz.com/">
                <h1>Marcel Jurtz</h1>
            </a>
            <p class="lead">
                 Notes and thoughts on software development 
            </p>
        </div>

        <nav>
            <ul class="sidebar-nav">
                <li><a href="https://www.mjurtz.com/">Home</a> </li>
                <li><a href="/about/"> About </a></li><li><a href="/imprint/"> Imprint / Impressum </a></li><li><a href="/privacy/"> Privacy / Datenschutz </a></li>
            </ul>
        </nav>

    </div>
</aside>
    <main class="content container">
    <div class="post">
  <h1>Building a Chess Game in Unity</h1>
  <time datetime=2017-11-13T17:57:49Z class="post-date">Mon, Nov 13, 2017</time>
  <p>In this post, I&rsquo;ll be covering the basics of building a simple chess game in Unity and C#.</p>
<p>The MVP of this project will be a fully playable 3D chess game for two players. Each character will only be able to make moves that comply with the rules. After slaying a king, the game is reset. To improve the game, menu scenes, statistics and a simple AI will be added later. The final project and its source code is available on my <a href="https://github.com/MarcelJurtz/Chess">GitHub-profile</a>.</p>
<p>Since this article became quite large, I split it into different parts. Use one of the following links to jump directly to the relevant section.</p>
<ol>
<li><a href="#loading_assets">Loading the Assets</a> for programmers lacking 3d-modeling skills</li>
<li><a href="#setting_up_scene">Setting up the Scene</a> to create a basic setting</li>
<li><a href="#drawing_chessboard">Drawing the Chessboard</a> to make testing easier</li>
<li><a href="#initialize_characters">Initializing the Characters</a> and move them to their default location</li>
<li><a href="#movement_control">Movement Control</a> to differentiate between selecting and moving characters</li>
<li><a href="#board_highlighting">Board Highlighting</a> to mark all fields to which can be moved</li>
<li><a href="#obey_rules">Obey the Rules</a> to implement each characters movesets</li>
</ol>
<h2 id="loading_assets">Loading the Assets</h2>
<p>I think it is quite common that programmers are bad designers. At least that&rsquo;s the case for me, which is why I try to get the graphic elements for my chess game from the Asset Store. I found <a href="https://www.assetstore.unity3d.com/en/#!/content/93014">Arcane Cyber&rsquo;s Classic Chess Set</a> to look pretty nice and decided to give it a shot. This asset pack contains three different types of figures (metallic, marble &amp; plastic), although the board is only available in the marble look.</p>
<h2 id="setting_up_scene">Setting up the Scene</h2>
<p>I start with creating a simple scene, which contains a camera and a light source, as well as an empty GameObject for the chessboard. The chessboards prefab is attached to this gameobject as a child element. Another child element is a simple plane, which I use for testing. For the time being, I deactivate the chess board itself to get a better overview.</p>
<p>As soon as the scene itself is finished, I start with the actual scripting. The parent element of the chess field receives a script called BoardManager, which manages the whole game.</p>
<h2 id="drawing_chessboard">Drawing the Chessboard</h2>
<p>The BoardManager has several tasks, which I&rsquo;ll be covering in the following. First of all, the manager loads all the characters at their starting positions. Then, possible movements are calculated and the observance of the alternating moves is checked.</p>
<p>I&rsquo;ll start by drawing a chessboard manually. This helps to test the correct movements and positioning inside the squares of the chess board. The method is called in the scripts Start()-method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> DrawChessBoard()
{
    Vector3 widthLine = Vector3.right * <span style="color:#ae81ff">8</span>;
    Vector3 heightLine = Vector3.forward * <span style="color:#ae81ff">8</span>;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt;= <span style="color:#ae81ff">8</span>; i++)
    {
        Vector3 start = Vector3.forward * i;
        Debug.DrawLine(start, start + widthLine);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j = <span style="color:#ae81ff">0</span>; j &lt;= <span style="color:#ae81ff">8</span>; j++)
        {
            start = Vector3.right * j;
            Debug.DrawLine(start, start + heightLine);
        }
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

This function generates an <span style="color:#ae81ff">8</span>x8 grid, which symbolizes the chess board and <span style="color:#66d9ef">is</span> now used to simplify the positioning of the chess pieces. Before I will position the game pieces next, I want to <span style="color:#66d9ef">add</span> a function to hold the current mouse position <span style="color:#66d9ef">on</span> the chess board. This function will be implemented <span style="color:#66d9ef">by</span> displaying a cross <span style="color:#66d9ef">on</span> the labelled field.

The currently selected position will be identified <span style="color:#66d9ef">by</span> two integer values, which represent X and Y position, ranging <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">0</span> to <span style="color:#ae81ff">7.</span> These two variables are defined at <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">level</span> and have a <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">value</span> of -<span style="color:#ae81ff">1</span>, which indicates that no field <span style="color:#66d9ef">on</span> the chessboard <span style="color:#66d9ef">is</span> selected. This <span style="color:#66d9ef">value</span> should also be assumed <span style="color:#66d9ef">if</span> the mouse position <span style="color:#66d9ef">is</span> outside of the chess field. To update the selection, I move the call of <span style="color:#ae81ff">_D</span>rawChessboard()<span style="color:#ae81ff">_</span> <span style="color:#66d9ef">from</span> the <span style="color:#ae81ff">_</span>Start()<span style="color:#ae81ff">_</span>- to the <span style="color:#ae81ff">_</span>Update()<span style="color:#ae81ff">_</span>-method.

I use a Raycast to check <span style="color:#66d9ef">if</span> the mouse <span style="color:#66d9ef">is</span> inside the board. I also assign the chessboard GameObject its own layer called <span style="color:#e6db74">&#34;ChessPlane&#34;</span>, which <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">checked</span> <span style="color:#66d9ef">for</span> availability <span style="color:#66d9ef">by</span> the Raycast.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> UpdateSelection()
{
    <span style="color:#66d9ef">if</span> (!Camera.main) <span style="color:#66d9ef">return</span>;

    RaycastHit hit;
    <span style="color:#66d9ef">float</span> raycastDistance = <span style="color:#ae81ff">25.0f</span>;
    <span style="color:#66d9ef">if</span> (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), <span style="color:#66d9ef">out</span> hit, raycastDistance, LayerMask.GetMask(<span style="color:#e6db74">&#34;ChessPlane&#34;</span>)))
    {
        selectionX = (<span style="color:#66d9ef">int</span>)hit.point.x;
        selectionY = (<span style="color:#66d9ef">int</span>)hit.point.z;
    }
    <span style="color:#66d9ef">else</span>
    {
        selectionX = -<span style="color:#ae81ff">1</span>;
        selectionY = -<span style="color:#ae81ff">1</span>;
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

This method <span style="color:#66d9ef">is</span> also called <span style="color:#66d9ef">in</span> the <span style="color:#ae81ff">_</span>Update()<span style="color:#ae81ff">_</span>-method. As you can see <span style="color:#66d9ef">in</span> the snippet above, only the X and Y variables are <span style="color:#66d9ef">set</span> <span style="color:#66d9ef">in</span> the method, but no corresponding changes are made to the graphical user <span style="color:#66d9ef">interface</span>. I implement <span style="color:#66d9ef">this</span> functionality <span style="color:#66d9ef">in</span> the <span style="color:#ae81ff">_D</span>rawChessBoard()<span style="color:#ae81ff">_</span>-method to maintain a clear code structure through the related functional area. So, after drawing the board itself, I use the following code to display the current mouse position. By <span style="color:#66d9ef">this</span> instruction, two further lines are drawn, which are represented <span style="color:#66d9ef">in</span> the form of a cross <span style="color:#66d9ef">on</span> the chess board.

<span style="color:#960050;background-color:#1e0010">```</span>csharpif (selectionX &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; selectionY &gt;= <span style="color:#ae81ff">0</span>)
{
    Debug.DrawLine(Vector3.forward * selectionY + Vector3.right * selectionX,
        Vector3.forward * (selectionY + <span style="color:#ae81ff">1</span>) + Vector3.right * (selectionX + <span style="color:#ae81ff">1</span>));
    Debug.DrawLine(Vector3.forward * selectionY + Vector3.right * (selectionX + <span style="color:#ae81ff">1</span>),
        Vector3.forward * (selectionY + <span style="color:#ae81ff">1</span>) + Vector3.right * selectionX);
}<span style="color:#960050;background-color:#1e0010">```</span>

<span style="color:#960050;background-color:#1e0010">##</span> Initializing the Characters {<span style="color:#960050;background-color:#1e0010">#</span>initialize_characters}

Next, the chess pieces are initialized and positioned at their respective locations. For <span style="color:#66d9ef">this</span> purpose I need information about the different game pieces, so a prefab <span style="color:#66d9ef">for</span> each piece has to be created. The package <span style="color:#66d9ef">from</span> the Asset Store I used already has prebuilt assets, but you<span style="color:#960050;background-color:#1e0010">&#39;</span>ll want to adjust the scaling and rotation.

I would like to create a <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">for</span> each type of character so that I can deduce the different possible movements later <span style="color:#66d9ef">on</span>. But <span style="color:#66d9ef">this</span> <span style="color:#66d9ef">is</span> not needed at the moment, so I create a superclass which describes each character and <span style="color:#66d9ef">is</span> later used <span style="color:#66d9ef">as</span> a parent <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">of</span> the different characters.

I<span style="color:#960050;background-color:#1e0010">&#39;</span>ve already done some preliminary work here, which <span style="color:#66d9ef">is</span> why <span style="color:#66d9ef">this</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">needs</span> an explanation. Each figure has a position, described <span style="color:#66d9ef">by</span> two-dimensional coordinates (X and Y). In addition, each figure <span style="color:#66d9ef">is</span> either white or black and should have information about the positions to which it may move. The differentiation between white and black figures <span style="color:#66d9ef">is</span> realized <span style="color:#66d9ef">by</span> a boolean. Alternatively, an enumeration could be used here <span style="color:#66d9ef">as</span> well, which I think would be better with regard to readability, but the boolean offers the advantage of comparing <span style="color:#66d9ef">this</span> property with a corresponding property of the <span style="color:#ae81ff">_</span>BoardManager_ to check the current active color and switching it with the != <span style="color:#66d9ef">operator</span>. I have provided the <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">with</span> the keyword <span style="color:#ae81ff">_</span>abstract_, which prevents the use of the <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">itself</span>, so only the subclasses can be used.

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChessFigure</span> : MonoBehaviour
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> CurrentX { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> CurrentY { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> isWhite;

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetPosition(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
    {
        CurrentX = x;
        CurrentY = y;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">8</span>];
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

So much <span style="color:#66d9ef">for</span> it. Next, a <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">is</span> created <span style="color:#66d9ef">for</span> each type of character, inherited <span style="color:#66d9ef">from</span> the superclass. Since these classes will only overwrite the possible movements, they <span style="color:#66d9ef">do</span> not contain any logic of their own at the moment. Remember to adjust the different prefabs after adding the script <span style="color:#66d9ef">using</span> the <span style="color:#66d9ef">public</span> property <span style="color:#e6db74">&#34;isWhite&#34;</span> and <span style="color:#66d9ef">set</span> the check mark <span style="color:#66d9ef">in</span> the editor to the white figures.

To assign the different prefabs to BoardManager, I<span style="color:#960050;background-color:#1e0010">&#39;</span>ll now <span style="color:#66d9ef">add</span> a <span style="color:#66d9ef">public</span> list of the GameObject type and <span style="color:#66d9ef">add</span> the different prefabs to it <span style="color:#66d9ef">in</span> the editor. The order of the instances <span style="color:#66d9ef">is</span> not important, but I recommend that you build a basic logic to make the instantiation <span style="color:#66d9ef">as</span> easy to read <span style="color:#66d9ef">as</span> possible later <span style="color:#66d9ef">on</span>. In my <span style="color:#66d9ef">case</span>, I use the following order:

  <span style="color:#ae81ff">1.</span> King (White)
  <span style="color:#ae81ff">2.</span> Queen (White)
  <span style="color:#ae81ff">3.</span> Rook (White)
  <span style="color:#ae81ff">4.</span> Bishop (White)
  <span style="color:#ae81ff">5.</span> Knight (White)
  <span style="color:#ae81ff">6.</span> Pawn (White)
  <span style="color:#ae81ff">7.</span> King (Black)
  <span style="color:#ae81ff">8.</span> Queen (Black)
  <span style="color:#ae81ff">9.</span> Rook (Black)
 <span style="color:#ae81ff">10.</span> Bishop (Black)
 <span style="color:#ae81ff">11.</span> Knight (Black)
 <span style="color:#ae81ff">12.</span> Pawn (Black)

To instantiate the different figures correctly, different functionalities are needed. The figure must start <span style="color:#66d9ef">on</span> the correct field, but also take the right position (centered) within the field. To calculate the center of a field, I created a method GetTileCenter (). This requires the information about the size of a field, which I have stored <span style="color:#66d9ef">in</span> a constant called TILE<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#ae81ff">_</span>SIZE (which <span style="color:#66d9ef">is</span> equal to <span style="color:#ae81ff">1</span>). I also calculate the center <span style="color:#66d9ef">using</span> an offset (TILE<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#ae81ff">_</span>OFFSET) of <span style="color:#ae81ff">0.5</span>. The parameters correspond to the coordinates of the respective figure <span style="color:#66d9ef">on</span> the chess board, which are represented <span style="color:#66d9ef">by</span> X and Y (<span style="color:#ae81ff">0</span>-<span style="color:#ae81ff">7</span>).

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate Vector3 GetTileCenter(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
{
    Vector3 origin = Vector3.zero;
    origin.x += (TILE_SIZE * x) + TILE_OFFSET;
    origin.z += (TILE_SIZE * y) + TILE_OFFSET;
    <span style="color:#66d9ef">return</span> origin;
}<span style="color:#960050;background-color:#1e0010">```</span>

This method <span style="color:#66d9ef">is</span> now called <span style="color:#66d9ef">by</span> another one, which <span style="color:#66d9ef">is</span> used to instantiate the figures. Here too, I have already implemented another functionality, which I must briefly explain. <span style="color:#ae81ff">_</span>ChessFigurePositions_ <span style="color:#66d9ef">is</span> a two-dimensional array of the type GameObject, which holds information about the positions of figures <span style="color:#66d9ef">on</span> the board. When an entry of <span style="color:#66d9ef">this</span> <span style="color:#66d9ef">is</span> equal to <span style="color:#66d9ef">null</span>, that means that no figure <span style="color:#66d9ef">is</span> located <span style="color:#66d9ef">on</span> that position. <span style="color:#ae81ff">_</span>ActiveFigures_ <span style="color:#66d9ef">is</span> list of the type GameObject, used to keep track of all characters that are currently alive.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> SpawnChessFigure(<span style="color:#66d9ef">int</span> index, <span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
{
    GameObject go = Instantiate(chessFigures[index], GetTileCenter(x, y), chessFigures[index].transform.rotation) <span style="color:#66d9ef">as</span> GameObject;
    go.transform.SetParent(transform);
    ChessFigurePositions[x, y] = go.GetComponent&lt;ChessFigure&gt;();
    ChessFigurePositions[x, y].SetPosition(x, y);
    activeFigures.Add(go);
}<span style="color:#960050;background-color:#1e0010">```</span>

With <span style="color:#66d9ef">this</span> method, it <span style="color:#66d9ef">is</span> now possible to instantiate game pieces, but there <span style="color:#66d9ef">is</span> no information <span style="color:#66d9ef">on</span> which position belongs to which figure. I create another method called <span style="color:#ae81ff">_</span>SpawnAllChessFigures()<span style="color:#ae81ff">_</span>, which handles <span style="color:#66d9ef">this</span> task. This <span style="color:#66d9ef">is</span> then called <span style="color:#66d9ef">in</span> the <span style="color:#ae81ff">_</span>Start()<span style="color:#ae81ff">_</span> method of the script and will later also be used to implement the functionality to reset the game. The only difficulty here lies <span style="color:#66d9ef">in</span> the correct positioning of the game pieces, which <span style="color:#66d9ef">is</span> determined <span style="color:#66d9ef">by</span> the parameters of the spawn function.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> SpawnAllChessFigures()
{
    <span style="color:#75715e">// White
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// King
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Queen
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Rook
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Rook
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Bishop
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Bishop
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Knight
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Knight
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1</span>);
    SpawnChessFigure(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>);

    <span style="color:#75715e">// Black
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// King
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Queen
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Rook
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Rook
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Bishop
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Bishop
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Knight
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>); <span style="color:#75715e">// Knight
</span><span style="color:#75715e"></span>    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>);
    SpawnChessFigure(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>);
}<span style="color:#960050;background-color:#1e0010">```</span>

<span style="color:#960050;background-color:#1e0010">##</span> Movement Control {<span style="color:#960050;background-color:#1e0010">#</span>movement_control}

After all characters have been added to the board, they need to be able to change their position. I splt <span style="color:#66d9ef">this</span> functionality <span style="color:#66d9ef">into</span> two parts. First of all, it must be possible to <span style="color:#66d9ef">select</span> a character <span style="color:#66d9ef">by</span> clicking <span style="color:#66d9ef">on</span> it. Afterwards, the selected character must be able to move to another location (considering its allowed moves) <span style="color:#66d9ef">as</span> far <span style="color:#66d9ef">as</span> it <span style="color:#66d9ef">is</span> the figures colors turn.

To implement <span style="color:#66d9ef">this</span> functionality, I have created two <span style="color:#66d9ef">new</span> methods <span style="color:#66d9ef">in</span> the <span style="color:#ae81ff">_</span>BoardManager_: <span style="color:#ae81ff">_</span>SelectChessFigure()<span style="color:#ae81ff">_</span> and <span style="color:#ae81ff">_</span>MoveChessFigure()<span style="color:#ae81ff">_.</span> To keep track of the currently active color, I have created a <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">wide</span> boolean-variable named <span style="color:#ae81ff">_</span>isWhiteTurn_, which can be compared to the <span style="color:#ae81ff">_</span>isWhite_ property of the individual characters. The call of these two functions <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">in</span> the <span style="color:#ae81ff">_</span>Update()<span style="color:#ae81ff">_</span>-method and listens <span style="color:#66d9ef">for</span> a mouse click.

<span style="color:#960050;background-color:#1e0010">```</span>csharpif(Input.GetMouseButtonDown(<span style="color:#ae81ff">0</span>))
{
    <span style="color:#66d9ef">if</span>(selectionX &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; selectionY &gt;= <span style="color:#ae81ff">0</span>)
    {
        <span style="color:#66d9ef">if</span>(selectedFigure == <span style="color:#66d9ef">null</span>) SelectChessFigure(selectionX, selectionY);
        <span style="color:#66d9ef">else</span> MoveChessFigure(selectionX, selectionY);
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

I have created another boolean-variable inside the method, which <span style="color:#66d9ef">is</span> used to monitor whether the selected figure can move at all. If <span style="color:#66d9ef">this</span> <span style="color:#66d9ef">is</span> not the <span style="color:#66d9ef">case</span>, the figure should not be selectable, so that a different figure can be selected directly afterwards. Otherwise, the selection of a field to which the piece should moved follows. In <span style="color:#66d9ef">case</span> of no other possible movement a <span style="color:#66d9ef">double</span> click <span style="color:#66d9ef">on</span> a <span style="color:#66d9ef">new</span> figure would be required, which <span style="color:#66d9ef">is</span> circumvented <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">this</span> implementation. So, the task of the nested <span style="color:#66d9ef">for</span>-loop <span style="color:#66d9ef">is</span> simply to check <span style="color:#66d9ef">if</span> the chosen figure <span style="color:#66d9ef">is</span> able to move.

If the figure <span style="color:#66d9ef">is</span> able to move, all available target fields should be highlighted. I have outsourced <span style="color:#66d9ef">this</span> functionality to another class, which I will discuss next. The array containing information <span style="color:#66d9ef">on</span> the available movements <span style="color:#66d9ef">is</span> also filled here. This calculation takes place <span style="color:#66d9ef">in</span> the different classes of the individual game pieces, which will also be discussed soon.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> SelectChessFigure(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
{
    <span style="color:#66d9ef">if</span> (ChessFigurePositions[x, y] == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span>;
    <span style="color:#66d9ef">if</span> (ChessFigurePositions[x, y].isWhite != isWhiteTurn) <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">bool</span> hasAtLeastOneMove = <span style="color:#66d9ef">false</span>;
    allowedMoves = ChessFigurePositions[x, y].PossibleMove();

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; <span style="color:#ae81ff">8</span>; i++)
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j = <span style="color:#ae81ff">0</span>; j &lt; <span style="color:#ae81ff">8</span>; j++)
        {
            <span style="color:#66d9ef">if</span>(allowedMoves[i,j])
            {
                hasAtLeastOneMove = <span style="color:#66d9ef">true</span>;
                i = <span style="color:#ae81ff">7</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }
    }

    <span style="color:#66d9ef">if</span> (!hasAtLeastOneMove) <span style="color:#66d9ef">return</span>;

    selectedFigure = ChessFigurePositions[x, y];
    BoardHighlighting.Instance.HighlightAllowedMoves(allowedMoves);
}<span style="color:#960050;background-color:#1e0010">```</span>

The <span style="color:#ae81ff">_</span>MoveChessFigure()<span style="color:#ae81ff">_</span>-Method <span style="color:#66d9ef">is</span> implemented quite simple. If there <span style="color:#66d9ef">is</span> already a different colored figure <span style="color:#66d9ef">on</span> the target field, it will be destroyed. If <span style="color:#66d9ef">this</span> figure happens to be a king, the <span style="color:#ae81ff">_</span>EndGame-()<span style="color:#ae81ff">_</span>-method <span style="color:#66d9ef">is</span> called, which resets the game. Afterwards, the board layout and position properties of the selected piece are updated.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> MoveChessFigure(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y)
{
    <span style="color:#66d9ef">if</span>(allowedMoves[x,y])
    {
        ChessFigure c = ChessFigurePositions[x, y];
        <span style="color:#66d9ef">if</span>(c != <span style="color:#66d9ef">null</span> &amp;&amp; c.isWhite != isWhiteTurn)
        {
            activeFigures.Remove(c.gameObject);
            Destroy(c.gameObject);

            <span style="color:#66d9ef">if</span>(c.GetType() == <span style="color:#66d9ef">typeof</span>(King))
            {
                EndGame();
                <span style="color:#66d9ef">return</span>;
            }
        }

        ChessFigurePositions[selectedFigure.CurrentX, selectedFigure.CurrentY] = <span style="color:#66d9ef">null</span>;
        selectedFigure.transform.position = GetTileCenter(x, y);
        selectedFigure.SetPosition(x, y);
        ChessFigurePositions[x, y] = selectedFigure;
        isWhiteTurn = !isWhiteTurn;
    }

    BoardHighlighting.Instance.HideHighlights();
    selectedFigure = <span style="color:#66d9ef">null</span>;
}<span style="color:#960050;background-color:#1e0010">```</span>

Another detail that <span style="color:#66d9ef">is</span> visible <span style="color:#66d9ef">in</span> the implementation of the <span style="color:#ae81ff">_</span>EndGame()<span style="color:#ae81ff">_</span>-method <span style="color:#66d9ef">is</span> the access to the <span style="color:#ae81ff">_</span>BoardHighlighting_-class. This was implemented <span style="color:#66d9ef">as</span> a singleton, whereby only one instance of the <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">can</span> exist, which <span style="color:#66d9ef">is</span> accessible <span style="color:#66d9ef">from</span> every area of the game.

<span style="color:#960050;background-color:#1e0010">```</span>csharpprivate <span style="color:#66d9ef">void</span> EndGame()
{
    <span style="color:#66d9ef">if</span> (isWhiteTurn)
        Debug.Log(<span style="color:#e6db74">&#34;White team won!&#34;</span>);
    <span style="color:#66d9ef">else</span>
        Debug.Log(<span style="color:#e6db74">&#34;Black team won!&#34;</span>);

    <span style="color:#66d9ef">foreach</span> (GameObject go <span style="color:#66d9ef">in</span> activeFigures)
        Destroy(go);

    isWhiteTurn = <span style="color:#66d9ef">true</span>;
    BoardHighlighting.Instance.HideHighlights();
    SpawnAllChessFigures();
}<span style="color:#960050;background-color:#1e0010">```</span>

<span style="color:#960050;background-color:#1e0010">##</span> Board Highlighting {<span style="color:#960050;background-color:#1e0010">#</span>board_highlighting}

The <span style="color:#ae81ff">_</span>BoardHighlighting_-<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">is</span> used to &lt;span&gt;emphasise &lt;/span&gt;possible target positions. I use a simple prefab <span style="color:#66d9ef">in</span> the form of a square plane, which <span style="color:#66d9ef">is</span> instantiated <span style="color:#66d9ef">on</span> the potential target fields. The possible fields are <span style="color:#66d9ef">set</span> <span style="color:#66d9ef">by</span> a parameter <span style="color:#66d9ef">in</span> form of a two-dimensional boolean array. The highlight objects are additionally managed <span style="color:#66d9ef">in</span> a list, which makes it easy to perform a reset between moves.

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BoardHighlighting</span> : MonoBehaviour {

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> BoardHighlighting Instance { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> GameObject highlightPrefab;
    <span style="color:#66d9ef">private</span> List&lt;GameObject&gt; highlights;

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Start()
    {
        Instance = <span style="color:#66d9ef">this</span>;
        highlights = <span style="color:#66d9ef">new</span> List&lt;GameObject&gt;();
    }

    <span style="color:#66d9ef">private</span> GameObject GetHighlightObject()
    {
        GameObject go = highlights.Find(g =&gt; !g.activeSelf);
        <span style="color:#66d9ef">if</span>(go == <span style="color:#66d9ef">null</span>)
        {
            go = Instantiate(highlightPrefab);
            highlights.Add(go);
        }
        <span style="color:#66d9ef">return</span> go;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> HighlightAllowedMoves(<span style="color:#66d9ef">bool</span>[,] moves)
    {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; <span style="color:#ae81ff">8</span>; i++)
        {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j = <span style="color:#ae81ff">0</span>; j &lt; <span style="color:#ae81ff">8</span>; j++)
            {
                <span style="color:#66d9ef">if</span> (moves[i, j])
                {
                    GameObject go = GetHighlightObject();
                    go.SetActive(<span style="color:#66d9ef">true</span>);
                    go.transform.position = <span style="color:#66d9ef">new</span> Vector3(i + <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0</span>, j + <span style="color:#ae81ff">0.5f</span>);
                }
            }
        }
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> HideHighlights()
    {
        <span style="color:#66d9ef">foreach</span> (GameObject go <span style="color:#66d9ef">in</span> highlights) go.SetActive(<span style="color:#66d9ef">false</span>);
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

And that<span style="color:#960050;background-color:#1e0010">&#39;</span>s it! Almost. The only thing missing <span style="color:#66d9ef">is</span> the assignment of the possible moves to the different pieces, which will be covered next.

<span style="color:#960050;background-color:#1e0010">##</span> Obeying the Rules {<span style="color:#960050;background-color:#1e0010">#</span>obey_rules}

The simplest character <span style="color:#66d9ef">is</span> also the most difficult to implement, so I<span style="color:#960050;background-color:#1e0010">&#39;</span>ll start with <span style="color:#66d9ef">this</span> one. Generally, the pawn can only move forward one field per turn. However, there are special regulations: <span style="color:#66d9ef">if</span> the pawn <span style="color:#66d9ef">is</span> located <span style="color:#66d9ef">on</span> its start field, then he<span style="color:#960050;background-color:#1e0010">&#39;</span>s allowed to move two fields forward. He can also not move forward <span style="color:#66d9ef">if</span> there <span style="color:#66d9ef">is</span> another character <span style="color:#66d9ef">on</span> that field. Finally, the pawn may only attack diagonally.

Because the direction <span style="color:#66d9ef">in</span> which the figures move <span style="color:#66d9ef">is</span> different, I implement <span style="color:#66d9ef">this</span> logic <span style="color:#66d9ef">for</span> both colors separately:

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Pawn</span> : ChessFigure
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">bool</span>[,] r = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>];
        ChessFigure c, c2;

        <span style="color:#66d9ef">if</span> (isWhite)
        {
            <span style="color:#75715e">// Diagonal Left
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(CurrentX != <span style="color:#ae81ff">0</span> &amp;&amp; CurrentY != <span style="color:#ae81ff">7</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX -<span style="color:#ae81ff">1</span>, CurrentY +<span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span>(c != <span style="color:#66d9ef">null</span> &amp;&amp; !c.isWhite) r[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY + <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }

            <span style="color:#75715e">// Diagonal Right
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (CurrentX != <span style="color:#ae81ff">7</span> &amp;&amp; CurrentY != <span style="color:#ae81ff">7</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY + <span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> (c != <span style="color:#66d9ef">null</span> &amp;&amp; !c.isWhite) r[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY + <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }

            <span style="color:#75715e">// Forward
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(CurrentY != <span style="color:#ae81ff">7</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY + <span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span>(c == <span style="color:#66d9ef">null</span>) r[CurrentX, CurrentY + <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }
            <span style="color:#75715e">// Two Steps Forward
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(CurrentY == <span style="color:#ae81ff">1</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY + <span style="color:#ae81ff">1</span>];
                c2 = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY + <span style="color:#ae81ff">2</span>];
                <span style="color:#66d9ef">if</span>(c == <span style="color:#66d9ef">null</span> &amp;&amp; c2 == <span style="color:#66d9ef">null</span>) r[CurrentX, CurrentY + <span style="color:#ae81ff">2</span>] = <span style="color:#66d9ef">true</span>;
            }
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">// Diagonal Left
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (CurrentX != <span style="color:#ae81ff">0</span> &amp;&amp; CurrentY != <span style="color:#ae81ff">0</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> (c != <span style="color:#66d9ef">null</span> &amp;&amp; c.isWhite) r[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }

            <span style="color:#75715e">// Diagonal Right
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (CurrentX != <span style="color:#ae81ff">7</span> &amp;&amp; CurrentY != <span style="color:#ae81ff">0</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> (c != <span style="color:#66d9ef">null</span> &amp;&amp; c.isWhite) r[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }

            <span style="color:#75715e">// Forward
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (CurrentY != <span style="color:#ae81ff">0</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY - <span style="color:#ae81ff">1</span>];
                <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[CurrentX, CurrentY - <span style="color:#ae81ff">1</span>] = <span style="color:#66d9ef">true</span>;
            }
            <span style="color:#75715e">// Two Steps Forward
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (CurrentY == <span style="color:#ae81ff">6</span>)
            {
                c = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY - <span style="color:#ae81ff">1</span>];
                c2 = BoardManager.Instance.ChessFigurePositions[CurrentX, CurrentY - <span style="color:#ae81ff">2</span>];
                <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span> &amp;&amp; c2 == <span style="color:#66d9ef">null</span>) r[CurrentX, CurrentY - <span style="color:#ae81ff">2</span>] = <span style="color:#66d9ef">true</span>;
            }
        }

        <span style="color:#66d9ef">return</span> r;
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

The next character I<span style="color:#960050;background-color:#1e0010">&#39;</span>m going to implement will be the bishop. The bishop can run any number of fields diagonally, <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">as</span> no other figures stand <span style="color:#66d9ef">in</span> the way.

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bishop</span> : ChessFigure
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">bool</span>[,] r = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>];

        ChessFigure c;
        <span style="color:#66d9ef">int</span> i, j;

        <span style="color:#75715e">// Top Left
</span><span style="color:#75715e"></span>        i = CurrentX;
        j = CurrentY;
        <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">true</span>)
        {
            i--;
            j++;
            <span style="color:#66d9ef">if</span> (i &lt; <span style="color:#ae81ff">0</span> || j &gt;= <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, j];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Top Right
</span><span style="color:#75715e"></span>        i = CurrentX;
        j = CurrentY;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i++;
            j++;
            <span style="color:#66d9ef">if</span> (i &gt;= <span style="color:#ae81ff">8</span> || j &gt;= <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, j];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Bottom Left
</span><span style="color:#75715e"></span>        i = CurrentX;
        j = CurrentY;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i--;
            j--;
            <span style="color:#66d9ef">if</span> (i &lt; <span style="color:#ae81ff">0</span> || j &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, j];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Bottom Right
</span><span style="color:#75715e"></span>        i = CurrentX;
        j = CurrentY;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i++;
            j--;
            <span style="color:#66d9ef">if</span> (i &gt;= <span style="color:#ae81ff">8</span> || j &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, j];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#66d9ef">return</span> r;
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

The rook <span style="color:#66d9ef">is</span> implemented <span style="color:#66d9ef">in</span> a similar way to the bishop, but the movement here <span style="color:#66d9ef">is</span> straight (vertical and horizontal) instead of diagonal.

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rook</span> : ChessFigure
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">bool</span>[,] r = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>];
        ChessFigure c;
        <span style="color:#66d9ef">int</span> i;

        <span style="color:#75715e">// Left
</span><span style="color:#75715e"></span>        i = CurrentX;
        <span style="color:#66d9ef">while</span>(<span style="color:#66d9ef">true</span>)
        {
            i--;
            <span style="color:#66d9ef">if</span> (i &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, CurrentY];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, CurrentY] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span>(c.isWhite != isWhite) r[i, CurrentY] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Right
</span><span style="color:#75715e"></span>        i = CurrentX;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i++;
            <span style="color:#66d9ef">if</span> (i &gt;= <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[i, CurrentY];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, CurrentY] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, CurrentY] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Forward
</span><span style="color:#75715e"></span>        i = CurrentY;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i++;
            <span style="color:#66d9ef">if</span> (i &gt;= <span style="color:#ae81ff">8</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[CurrentX, i];
            <span style="color:#66d9ef">if</span>(c == <span style="color:#66d9ef">null</span>) r[CurrentX, i] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span>(c.isWhite != isWhite) r[CurrentX, i] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// Back
</span><span style="color:#75715e"></span>        i = CurrentY;
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            i--;
            <span style="color:#66d9ef">if</span> (i &lt; <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
            c = BoardManager.Instance.ChessFigurePositions[CurrentX, i];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[CurrentX, i] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[CurrentX, i] = <span style="color:#66d9ef">true</span>;
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#66d9ef">return</span> r;
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

Another complicated looking figure <span style="color:#66d9ef">is</span> the knight. The knight moves two fields straight ahead <span style="color:#66d9ef">in</span> one direction, followed <span style="color:#66d9ef">by</span> a <span style="color:#ae81ff">90</span> degree turn and a further movement <span style="color:#66d9ef">by</span> one field <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">this</span> direction. Alternatively, the movement of a single field can be done first, followed <span style="color:#66d9ef">by</span> the two-field-movement. Figures that are <span style="color:#66d9ef">on</span> the fields within the movement sequence are irrelevant. However, the knight has a positive side: the movements <span style="color:#66d9ef">do</span> not have to be implemented separately <span style="color:#66d9ef">for</span> both colors.

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Knight</span> : ChessFigure
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">bool</span>[,] r = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>];

        <span style="color:#75715e">// Up / Left
</span><span style="color:#75715e"></span>        KnightMove(CurrentX - <span style="color:#ae81ff">1</span>, CurrentY + <span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">ref</span> r);
        KnightMove(CurrentX - <span style="color:#ae81ff">2</span>, CurrentY + <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">ref</span> r);

        <span style="color:#75715e">// Up / Right
</span><span style="color:#75715e"></span>        KnightMove(CurrentX + <span style="color:#ae81ff">1</span>, CurrentY + <span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">ref</span> r);
        KnightMove(CurrentX + <span style="color:#ae81ff">2</span>, CurrentY + <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">ref</span> r);

        <span style="color:#75715e">// Down / Left
</span><span style="color:#75715e"></span>        KnightMove(CurrentX - <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">ref</span> r);
        KnightMove(CurrentX - <span style="color:#ae81ff">2</span>, CurrentY - <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">ref</span> r);

        <span style="color:#75715e">// Down / Right
</span><span style="color:#75715e"></span>        KnightMove(CurrentX + <span style="color:#ae81ff">1</span>, CurrentY - <span style="color:#ae81ff">2</span>, <span style="color:#66d9ef">ref</span> r);
        KnightMove(CurrentX + <span style="color:#ae81ff">2</span>, CurrentY - <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">ref</span> r);

        <span style="color:#66d9ef">return</span> r;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> KnightMove(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">bool</span>[,] r)
    {
        ChessFigure c;
        <span style="color:#66d9ef">if</span>(x &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; x &lt; <span style="color:#ae81ff">8</span> &amp;&amp; y &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; y &lt; <span style="color:#ae81ff">8</span>)
        {
            c = BoardManager.Instance.ChessFigurePositions[x, y];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[x, y] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[x, y] = <span style="color:#66d9ef">true</span>;
        }
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

The possible movements of the king correspond to two fields <span style="color:#66d9ef">in</span> any direction, which I have implemented <span style="color:#66d9ef">as</span> follows:

<span style="color:#960050;background-color:#1e0010">```</span>csharppublic <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">King</span> : ChessFigure
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">bool</span>[,] PossibleMove()
    {
        <span style="color:#66d9ef">bool</span>[,] r = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>];

        ChessFigure c;
        <span style="color:#66d9ef">int</span> i, j;

        <span style="color:#75715e">// Top
</span><span style="color:#75715e"></span>        i = CurrentX - <span style="color:#ae81ff">1</span>;
        j = CurrentY + <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span>(CurrentY &lt; <span style="color:#ae81ff">7</span>)
        {
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k = <span style="color:#ae81ff">0</span>; k &lt; <span style="color:#ae81ff">3</span>; k++)
            {
                <span style="color:#66d9ef">if</span>(i &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; i &lt; <span style="color:#ae81ff">8</span>)
                {
                    c = BoardManager.Instance.ChessFigurePositions[i, j];
                    <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                }
                i++;
            } 
        }

        <span style="color:#75715e">// Bottom
</span><span style="color:#75715e"></span>        i = CurrentX - <span style="color:#ae81ff">1</span>;
        j = CurrentY - <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (CurrentY &gt; <span style="color:#ae81ff">0</span>)
        {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k = <span style="color:#ae81ff">0</span>; k &lt; <span style="color:#ae81ff">3</span>; k++)
            {
                <span style="color:#66d9ef">if</span> (i &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; i &lt; <span style="color:#ae81ff">8</span>)
                {
                    c = BoardManager.Instance.ChessFigurePositions[i, j];
                    <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[i, j] = <span style="color:#66d9ef">true</span>;
                    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[i, j] = <span style="color:#66d9ef">true</span>;
                }
                i++;
            }
        }

        <span style="color:#75715e">// Left
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(CurrentX &gt; <span style="color:#ae81ff">0</span>)
        {
            c = BoardManager.Instance.ChessFigurePositions[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[CurrentX - <span style="color:#ae81ff">1</span>, CurrentY] = <span style="color:#66d9ef">true</span>;
        }

        <span style="color:#75715e">// Right
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (CurrentX &lt; <span style="color:#ae81ff">7</span>)
        {
            c = BoardManager.Instance.ChessFigurePositions[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY];
            <span style="color:#66d9ef">if</span> (c == <span style="color:#66d9ef">null</span>) r[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY] = <span style="color:#66d9ef">true</span>;
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c.isWhite != isWhite) r[CurrentX + <span style="color:#ae81ff">1</span>, CurrentY] = <span style="color:#66d9ef">true</span>;
        }

        <span style="color:#66d9ef">return</span> r;
    }
}<span style="color:#960050;background-color:#1e0010">```</span>

And last but not least, the queen<span style="color:#960050;background-color:#1e0010">&#39;</span>s movements are still missing. These seem to be quite complex again, but here you can simply combine the already created movements of rook and bishop, which <span style="color:#66d9ef">is</span> why I don<span style="color:#960050;background-color:#1e0010">&#39;</span>t separately <span style="color:#66d9ef">add</span> a snippet of the source code <span style="color:#66d9ef">for</span> the queens implementation.

Now that<span style="color:#960050;background-color:#1e0010">&#39;</span>s it! The functionality of the MVP defined at the beginning <span style="color:#66d9ef">is</span> fully implemented. I will now <span style="color:#66d9ef">try</span> to implement a simple AI, which will help you to play the game without disturbing social interaction. Stay tuned!</code></pre></div>
</div>


    </main>

    
      
    
  </body>
</html>
