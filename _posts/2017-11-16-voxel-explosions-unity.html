---
layout: post
title: Voxel Explosions in Unity
date: 2017-11-16 18:00:04.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Game development
tags:
- ".NET"
- CSharp
- Development
- GameDev
- Programming
- Unity
meta:
  _edit_last: '2'
  _adinserter_block_exceptions: ''
  _yoast_wpseo_focuskw_text_input: Voxel
  _yoast_wpseo_focuskw: Voxel
  _yoast_wpseo_metadesc: In this article, I describe the process of creating a voxel
    explosion effect which can be applied to GameObjects in Unity.
  _yoast_wpseo_linkdex: '83'
  _yoast_wpseo_content_score: '90'
  _yoast_wpseo_primary_category: '23'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1510941445;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:504;}i:1;a:1:{s:2:"id";i:340;}i:2;a:1:{s:2:"id";i:485;}}}}
  _wpas_done_all: '1'
author:
  login: Marcel
  email: marcel@mjurtz.com
  display_name: Marcel Jurtz
  first_name: Marcel
  last_name: Jurtz
---
<p>This article describes the process of creating voxel explosions in Unity by using particles. For our models, we use <a href="https://ephtracy.github.io/">MagicaVoxel</a>, but every other tool can be used as well. The final result will look similar to this:</p>
<p>[embed]https://youtu.be/n4mzQTFuP68[/embed]</p>
<h2>Setting up the test environment</h2>
<p>For test purposes, I've set up a basic FPS environment using the built-in CharacterController package. I then added a gun model to the <em>FirstPersonCharacter </em>game object, which is located as child element in the hierarchy of the <em>FPSController</em>. The following snippet shows the code I added as a custom script component to the gun:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">using UnityEngine;

public class GunScript : MonoBehaviour {

    public Camera FPSCamera;
    public float maxDistance = 100f;

    public AudioClip shot;
    float fireRate = 0.5f;
    private float nextFire = 0.0f;
    private Transform t;

    void Start () {
        t = transform;
    }

    void Update ()
    {
        if(Input.GetButtonDown("Fire1") &amp;&amp; IsOkToShoot())
        {
            Shoot();
        }
    }

    void Shoot()
    {
        AudioSource.PlayClipAtPoint(shot, t.position);
        RaycastHit rcHit;
        if(Physics.Raycast(FPSCamera.transform.position, FPSCamera.transform.forward, out rcHit, maxDistance))
        {
            if(rcHit.transform.tag == "Enemy")
            {
                ExplosionScript ex = rcHit.transform.gameObject.GetComponent&lt;ExplosionScript&gt;();
                
                if(ex != null)
                {
                    ex.Explode(rcHit.point);
                }
            }
        }
    }

    bool IsOkToShoot()
    {
        bool fireable = false;
        if (Time.time &gt; nextFire) {
            nextFire = Time.time + fireRate;
            fireable = true;
        }
        return fireable;
    }
}</pre>
<p>So basically, this script takes up three public variables, one for the camera of the controller, which is needed to shoot from the player's perspective, a maxDistance to set how far can be shot, and an AudioClip to play a sound file when a shot has been fired. Additionally, there are a few private variables:</p>
<ul>
<li><em>fireRate,</em> to set how fast shots can be fired after each other</li>
<li><em>nextFire</em>, which is used to determine when a shot can be fired</li>
<li><em>t</em>, which represents the transform component of the current gameObject</li>
</ul>
<p>Every frame I check if the left mouse button is pressed. If so, a shot should be fired if the method <em>IsOkToShoot()</em> returns <em>true</em>. This happens when the current time minus the last time shot is larger than the previously set <em>fireRate</em>.</p>
<p>When an actual shot happens, the sound is being played where <em>t.position</em> determines the location from where the shot is going to be heard. After that, I call up a ray cast to scan the targeted environment for possible targets. The outgoing argument <em>hit</em> provides information about the target that has been hit (if nothing has been hit, the code inside the outermost if-statement will not be executed).</p>
<p>I created a custom tag called <em>Enemy</em>, which is going to be added to all the objects I want to hit. These are going to get a custom script called <em>ExplosionScript</em>, which contains a method named <em>Explode</em>. The next step is to build this script and actually blow something up.</p>
<h2>Exploding Voxels</h2>
<p>I'm using a basic model for testing purposes, that can bee seen in the screenshot below.</p>
<p><img src="{{ site.baseurl }}/assets/voxelexplosion_1.png" alt="Model for explosion" class="aligncenter size-full wp-image-508" width="300" height="169" /></p>
<p>It currently consists of an empty <em>GameObject</em> as parent, which has been expaned by adding a <em>MeshCollider</em>. The child element contains the actual content.</p>
<p>At first, a <em>ParticleSystem</em> is going to be added to the object. I use the following configuration here:</p>
<p><img src="{{ site.baseurl }}/assets/voxelexplosion_2.png" alt="Voxel explosion particle configuration" class="aligncenter size-full wp-image-509" width="503" height="1518" /></p>
<p>Note that the last setting (shader) can't be set yet. That will be created later. Also, <em>ExplosionMat</em> is just a regular material. After configuring the <em>ParticleSystem</em>, the animation should look like some cubes exploding and falling on the ground. Now the colors of the cubes need to be adjusted. The problem is, that a custom shader and a bit of additional coding is needed here. Now you just create a new prefab and move the <em>ParticleSystem</em> onto it. Then delete it from the object that has been used for testing.</p>
<p>I'll start with the shader. You use the context menu and add a new <em>shader</em> - <em>standard surface shader</em>. You can open the newly created file with Visual Studio (or whatever editor you want) and edit it to match our plan:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">Shader "Custom/ExplosionShader" {
    Properties {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Glossiness ("Smoothness", Range(0,1)) = 0.5
        _Metallic ("Metallic", Range(0,1)) = 0.0
    }
    SubShader {
        Tags { "RenderType"="Opaque" }
        LOD 200
        
        CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf Standard fullforwardshadows

        // Use shader model 3.0 target, to get nicer looking lighting
        #pragma target 3.0

        sampler2D _MainTex;

        struct Input {
            float2 uv_MainTex;
            
            // NEW LINE
            float4 vertexColor : COLOR;
        };

        half _Glossiness;
        half _Metallic;
        fixed4 _Color;

        void surf (Input IN, inout SurfaceOutputStandard o) {
            // Albedo comes from a texture tinted by color
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;
            
            // NEW LINE:
            c *= IN.vertexColor;


            o.Albedo = c.rgb;
            // Metallic and smoothness come from slider variables
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}</pre>
<p>There are two lines that need to be adjusted, I've marked them with the comment <em>//NEW LINE</em>. After that, the currently used material for the particles should be set to the color white. The color that is going to be set later will be mixed with the default color, and if that isn't white the colors won't match our wanted ones. Also, the shader of the material needs to be set to the newly created one.</p>
<p>An additional script is needed to edit the palette.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">using UnityEngine;

public class ExplosionScript : MonoBehaviour {

    public GameObject explosionPrefab;
    private GameObject explosion;
    bool exploding = false;

    public string colorDescriptor;
    private Color32[] colors;

    public void Explode(Vector3 pos)
    {
        explosion = Instantiate(explosionPrefab, pos, Quaternion.Euler(0f,0f,0f));
        exploding = true;       
    }

    private void LateUpdate()
    {
        if(exploding)
        {
            ParticleSystem explosionParticleSystem = explosion.GetComponent&lt;ParticleSystem&gt;();
            ParticleSystem.Particle[] particles = new ParticleSystem.Particle[explosionParticleSystem.main.maxParticles];
            colors = ColorManager.getColor(colorDescriptor);
            int numParticlesAlive = explosionParticleSystem.GetParticles(particles);
            for (int i = 0; i &lt; numParticlesAlive; i++)
            {
                particles[i].startColor = colors[Random.Range(0, colors.Length)];
            }
            explosionParticleSystem.SetParticles(particles, numParticlesAlive);
            exploding = false;

            Destroy(gameObject);
        }       
    }
}</pre>
<p>Again, here are some public and private variables:</p>
<ul>
<li><em>explosionPrefab</em> represents the prefab containing the ParticleSystem</li>
<li><em>explosion</em> is an instance of the prefab</li>
<li><em>exploding</em> is a flag for controlling the explosion</li>
<li><em>colors</em> is an array containing the colors that are going to be assigned to the exploding particles</li>
</ul>
<p>The first method starts the explosion. It instantiates the explosion at a given position, which is going to be where the ray cast hit the object. In <em>LateUpdate()</em>, the particles are going to be painted. This method is only run, when the exploding-flag is set to <em>true</em>, and it is also run only once, which is why the flag is set to <em>false</em> again at the end.</p>
<p>The <em>gameObject</em> itself is destroyed in the very end, since it is needed to assign its properties to the <em>ParticleSystem</em> created at runtime.</p>
<p>All the particles of the explosion are collected inside the <em>particles </em>array. The for-loop is iterating through all of the particles and assigns a new color. The color is determined via random selection of a color of the above-mentioned array. I found this solution to be a bit ugly, so I created another script called <em>ColorManager</em>, which contains arrays for each of my models. It basically just contains the following code:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="csharp">private static Color32[] foxColors =
{
    new Color32(238, 0, 0, 255),
    new Color32(0, 0, 34, 255),
    new Color32(238,238,238,255),
    new Color32(187,187,187,255)
};

private static Color32[] chickenColors =
{
    new Color32(238,238,238,255),
    new Color32(238,0,0,255),
    new Color32(255,102,0,255),
    new Color32(0,0,17,255)
};

private static Color32[] emptyColors =
{
    new Color32(255,255,255,255)
};

public static Color32[] getColor(string colorDescription)
{
    switch(colorDescription)
    {
        case "fox":
            return foxColors;
        case "chicken":
            return chickenColors;
        default:
            return emptyColors;
    }
}</pre>
<p>&nbsp;</p>
<p>Note that you can view the colors that have been used using MagicaVoxel by clicking on the tool marked by a <em>smaller-than sign</em> and then clicking on <em>HSV</em>.</p>
<p><img src="{{ site.baseurl }}/assets/voxelexplosion_3.png" alt="Get used colors from MagicaVoxel" class="aligncenter size-full wp-image-510" width="1024" height="576" /></p>
<p>If this is done, the explosions should work!</p>
